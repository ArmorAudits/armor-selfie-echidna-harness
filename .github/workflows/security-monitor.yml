name: Security Monitor

on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install Python deps for monitor
        run: pip install -r monitor/requirements.txt

      - name: Run doctor (tool inventory checks)
        run: python monitor/doctor.py --inventory monitor/tools.csv

      - name: Generate SBOM (SPDX JSON)
        uses: anchore/sbom-action@v0
        with:
          path: .
          format: spdx-json
          output-file: artifacts/sbom.spdx.json

      - name: Scan SBOM with grype (fail on High+)
        uses: anchore/grype-action@v1
        with:
          sbom: artifacts/sbom.spdx.json
          fail-on-severity: high

      - name: Upload security artifacts
        uses: actions/upload-artifact@v4
        with:
          name: security-artifacts
          path: artifacts/*

      - name: Post-process alerts (allow archived)
        run: |
          python - <<'PY'
          import os, sys, pathlib
          pathlib.Path("scripts").mkdir(exist_ok=True)
          # copy the same script into CI workspace
          open("scripts/alerts_allow_archived.py","w").write("""REPLACED_AT_RUNTIME""")
          sys.exit(0)
          PY
          # Replace placeholder with repo version if present
          if [ -f scripts/alerts_allow_archived.py ]; then rm scripts/alerts_allow_archived.py; fi
          cat > scripts/alerts_allow_archived.py <<'PYFILE'
          # (identical to local script)
          import csv, re, sys
          from pathlib import Path
          csv_path = Path("monitor/tools.csv")
          alerts = Path("artifacts/alerts.md")
          if not alerts.exists():
              sys.exit(0)
          def allowed_set():
              try:
                  rows = list(csv.DictReader(open(csv_path, newline='', encoding='utf-8')))
              except FileNotFoundError:
                  return set()
              s = set()
              for r in rows:
                  if str((r.get("AllowArchived") or "")).strip().lower() in {"true","1","yes","y"}:
                      t = (r.get("Tool") or "").strip().lower()
                      if t: s.add(t)
              return s
          allowed = allowed_set()
          lines = alerts.read_text(encoding="utf-8").splitlines(True)
          start = None
          for i,l in enumerate(lines):
              if l.strip().lower().startswith("## quarantined"):
                  start = i; break
          if start is None:
              sys.exit(0)
          end = len(lines)
          for j in range(start+1, len(lines)):
              if lines[j].startswith("## "):
                  end = j; break
          section = lines[start:end]
          head = section[0]
          bullets = section[1:]
          import re
          def tool_name_from_bullet(b):
              m = re.search(r"- \*\*(.+?)\*\*", b)
              return (m.group(1).strip().lower() if m else "")
          keep, moved = [], []
          for b in bullets:
              if b.strip().startswith("- "):
                  n = tool_name_from_bullet(b)
                  (moved if n in allowed else keep).append(b)
              else:
                  keep.append(b)
          new_section = [head]
          new_section += (keep if keep else ["(none)\n"])
          allowed_section = []
          if moved:
              allowed_section.append("\n## Allowed (archived)\n")
              allowed_section.append("_These tools are upstream-archived but explicitly allowed via `monitor/tools.csv` (AllowArchived=true)._ \n\n")
              allowed_section += moved
          new_lines = lines[:start] + new_section + lines[end:] + allowed_section
          alerts.write_text("".join(new_lines), encoding="utf-8")
          print(f"CI: moved {len(moved)} allowed item(s).")
          PYFILE
          python scripts/alerts_allow_archived.py
